-- Migration: Add chat sessions/messages, user_api_keys, subscribers, and supporting policies/views
-- Generated by Copilot on 2025-09-22

begin;

-- Ensure uuid generator is available
create extension if not exists pgcrypto with schema public;

-- Chat sessions table
create table if not exists public.chat_sessions (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  title text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

comment on table public.chat_sessions is 'AI chat sessions per user';

-- Chat messages table
create table if not exists public.chat_messages (
  id uuid primary key default gen_random_uuid(),
  session_id uuid not null references public.chat_sessions(id) on delete cascade,
  user_id uuid not null references auth.users(id) on delete cascade,
  role text not null check (role in ('user','assistant')),
  content text not null,
  created_at timestamptz not null default now()
);

-- Helpful indexes
create index if not exists idx_chat_sessions_user_updated on public.chat_sessions(user_id, updated_at desc);
create index if not exists idx_chat_messages_session_created on public.chat_messages(session_id, created_at desc);

-- Row Level Security
alter table public.chat_sessions enable row level security;
alter table public.chat_messages enable row level security;

-- Policies for chat_sessions: owner can do everything
do $$ begin
  if not exists (
    select 1 from pg_policies where schemaname='public' and tablename='chat_sessions' and policyname='allow owner all'
  ) then
    create policy "allow owner all" on public.chat_sessions
      using (auth.uid() = user_id)
      with check (auth.uid() = user_id);
  end if;
end $$;

-- Policies for chat_messages
do $$ begin
  if not exists (
    select 1 from pg_policies where schemaname='public' and tablename='chat_messages' and policyname='allow owner read'
  ) then
    create policy "allow owner read" on public.chat_messages
      for select
      using (
        exists (
          select 1 from public.chat_sessions s
          where s.id = session_id and s.user_id = auth.uid()
        )
      );
  end if;

  if not exists (
    select 1 from pg_policies where schemaname='public' and tablename='chat_messages' and policyname='allow owner write'
  ) then
    create policy "allow owner write" on public.chat_messages
      for all
      using (
        auth.uid() = user_id and exists (
          select 1 from public.chat_sessions s
          where s.id = session_id and s.user_id = auth.uid()
        )
      )
      with check (
        auth.uid() = user_id and exists (
          select 1 from public.chat_sessions s
          where s.id = session_id and s.user_id = auth.uid()
        )
      );
  end if;
end $$;

-- Trigger to bump session.updated_at on new messages
create or replace function public.touch_chat_session() returns trigger language plpgsql as $$
begin
  update public.chat_sessions set updated_at = now() where id = new.session_id;
  return new;
end $$;

do $$ begin
  if not exists (select 1 from pg_trigger where tgname='trg_touch_chat_session') then
    create trigger trg_touch_chat_session
      after insert on public.chat_messages
      for each row execute function public.touch_chat_session();
  end if;
end $$;

-- Generic updated_at trigger for chat_sessions when the row is updated directly (e.g., title change)
create or replace function public.set_timestamp_updated_at() returns trigger language plpgsql as $$
begin
  new.updated_at = now();
  return new;
end $$;

do $$ begin
  if not exists (select 1 from pg_trigger where tgname = 'trg_set_updated_at_chat_sessions') then
    create trigger trg_set_updated_at_chat_sessions
      before update on public.chat_sessions
      for each row execute function public.set_timestamp_updated_at();
  end if;
end $$;

-- View for session summaries
create or replace view public.chat_session_summaries as
  select
    s.id,
    s.user_id,
    coalesce(
      s.title,
      left((select m.content from public.chat_messages m where m.session_id = s.id order by m.created_at asc limit 1), 80),
      'Untitled Chat'
    ) as derived_title,
    s.created_at,
    s.updated_at,
    (select count(*)::int from public.chat_messages m where m.session_id = s.id) as message_count,
    coalesce((select max(m.created_at) from public.chat_messages m where m.session_id = s.id), s.updated_at) as last_message_at
  from public.chat_sessions s;

-- User API keys storage
create table if not exists public.user_api_keys (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  provider text not null,
  encrypted_key text not null,
  created_at timestamptz not null default now(),
  unique (user_id, provider)
);

alter table public.user_api_keys enable row level security;

do $$ begin
  if not exists (
    select 1 from pg_policies where schemaname='public' and tablename='user_api_keys' and policyname='allow owner manage keys'
  ) then
    create policy "allow owner manage keys" on public.user_api_keys
      using (auth.uid() = user_id)
      with check (auth.uid() = user_id);
  end if;
end $$;

-- Subscribers table for Stripe updates (service role will write)
create table if not exists public.subscribers (
  email text primary key,
  user_id uuid null references auth.users(id) on delete set null,
  stripe_customer_id text null,
  subscribed boolean not null default false,
  subscription_tier text null,
  subscription_end timestamptz null,
  updated_at timestamptz not null default now()
);

commit;
